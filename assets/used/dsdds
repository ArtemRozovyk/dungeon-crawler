supposons que vous avez un type "EtatDuJeu" par exemple
vous écrivez une propriété "prop_inv_EtatDuJeu" qui vérifie les invariants de ce type de type EtatDuJeu -> Bool (par exemple)
puis vous écrivez une opération
par exemple "ajouteMob" qui ajoute un mob à l'état du jeu
de type EtatDuJeu -> Mob -> EtatDuJeu (par exemple)
tout de suite apres vous écrivez une précondition
"prop_pre_ajouteMob" de type "EtatDuJeu -> Mob -> Bool" qui décide si vous avez le droit d'ajouter un mob sur un etatdujeu précis
puis vous écrivez une fonction "prop_post_ajouteMob -> EtatDuJeu -> Mob -> Bool" qui vérifie que l'appel d'ajouteMob a correctemetn fonctionné (par exemple en vérifiant que le mbo se trouve bien dans le nouvel EtatDuJeu)
ensuite vous passez au test de "ajouteMob"
1) pour tester une opération vous devez construire une "situation initale correcte"
il vous faut générer un e :: EtatDuJeu et un m :: Mob tels que
a) prop_inv_EtatDuJeu e soit True
b) prop_pre_ajouteMob e m  soit True
2) vous calculez le résultat de ajouteMob e m
3) vous testez l'invariant prop_inv_EtatDuJeu (ajouteMob e m) et la postcondition (prop_post_ajouteMob e m)
les 2 tests de 3) doivent être vert
la difficulté n'est pas d'écrire les tests
puisque vous avez écrit les inv et post, vous avez juste à les appeler
la difficulté c'est le 1), obtenir une situation initiale de test correcte et intéressante
deux manières de procéder
I) vous les créer à la main et faites plusieurs tests HSpec pour chaque opération. C'est souvent comme ça qu'on procède dans l'industrie, on écrit des situations de tests à la main et on lance les tests.
II) vous écrivez un générateur QuickCheck qui génère de bonnes situations de test
sauf que si vous le faites naïvement
typiquement en combinant des générateurs de bases et utilisant suchThat sur l'invariant et la précondition
votre PC va partir dans l'espace au moment de faire les tests
(il va générer des milliards de situations initiales et rejeter les 99.99999...% de celles qui ne satisfont pas les suchThat)
donc il faut souvent que vous écriviez le générateur à la main
ou en utilisant intelligemment la composition monadique
c'est pourquoi le test QuickCheck est considéré comme une extension
qui sera valorisée dans la notation
ça force à être malin en manipulant les générateurs
pour un rendu "standard" (qui vous permet quand même d'avoir la note maximale si le projet est parfait et que vous implémentez plusieurs extensions intéressantes)
vous pouvez vous contenter de tests HSpec
qui sont plus faciles à mettre en oeuvre
